var Scheduler=function(e){"use strict";e=e&&e.hasOwnProperty("default")?e.default:e;class t{schedule(e){}delay(e,t){}}const n=(t,n,s)=>{const c=new e;return"function"==typeof n?t(()=>s(c)):c.cancel(),c},s=e=>t=>n(e,t,e=>e.cancel()&&t()),c=e=>(t,s)=>n(e,t,e=>{if(e.cancelled)return;const n=setTimeout(()=>e.cancel()&&t(),s);e.addEventListener("cancel",()=>clearTimeout(n))});let r;const a=e=>requestAnimationFrame(e),u=s(a),i=c(a);class l extends t{static get instance(){return void 0===r&&(r=new l),r}schedule(e){return u(e)}delay(e,t){return i(e,t)}}let d;const o=e=>Promise.resolve().then(e),g=s(o),m=c(o);class h extends t{static get instance(){return void 0===d&&(d=new h),d}schedule(e){return g(e)}delay(e,t){return m(e,t)}}let y;const f=e=>setTimeout(e,0),v=s(f),w=c(f);class x extends t{static get instance(){return void 0===y&&(y=new x),y}schedule(e){return v(e)}delay(e,t){return w(e,t)}}let T;const p=e=>e(),P=s(p),b=c(p);class q extends t{static get instance(){return void 0===T&&(T=new q),T}schedule(e){return P(e)}delay(e,t){return b(e,t)}}return class{static get interface(){return t}static get current(){return q.instance}static get immediate(){return l.instance}static get async(){return h.instance}static get timeout(){return x.instance}}}(Cancellable);