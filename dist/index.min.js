var Scheduler=function(e){"use strict";e=e&&e.hasOwnProperty("default")?e.default:e;class t{schedule(e){}delay(e,t){}}const n=(t,n,s)=>{const r=new e;return"function"==typeof n?t(()=>s(r)):r.cancel(),r},s=e=>t=>n(e,t,e=>!e.cancelled&&t()),r=e=>(t,s)=>n(e,t,e=>{if(e.cancelled)return;const n=setTimeout(t,s);e.addEventListener("cancel",()=>clearTimeout(n))});let c;const a=e=>requestAnimationFrame(e),u=s(a),i=r(a);class l extends t{static get instance(){return void 0===c&&(c=new l),c}schedule(e){return u(e)}delay(e,t){return i(e,t)}}let d;const o=e=>Promise.resolve().then(e),g=s(o),m=r(o);class h extends t{static get instance(){return void 0===d&&(d=new h),d}schedule(e){return g(e)}delay(e,t){return m(e,t)}}let y;const f=e=>setTimeout(e,0),v=s(f),w=r(f);class x extends t{static get instance(){return void 0===y&&(y=new x),y}schedule(e){return v(e)}delay(e,t){return w(e,t)}}let T;const p=e=>e(),P=s(p),b=r(p);class q extends t{static get instance(){return void 0===T&&(T=new q),T}schedule(e){return P(e)}delay(e,t){return b(e,t)}}return class{static get interface(){return t}static get current(){return q.instance}static get immediate(){return l.instance}static get async(){return h.instance}static get timeout(){return x.instance}}}(Cancellable);